* 13. 文件输入/输出
** 
** 13.1 与文件进行通信
**** 文件重定向:从文件中读取信息或把信息写入文件。
***** echo "Hello World" >> a.c
***** cat a.c >> b.c
**** 这里学习用特殊I/O函数读取文件信息跟写入。
**** 
*** 13.1.1 文件是什么
**** file(文件):在磁盘、固态硬盘上的一段命名的存储区(有点像指针)。大型文件可能分开储存。
**** C把文件看成一段连续字节，每个字节都能单独读取。
**** C提供两种文件模式:文本模式、二进制模式。
**** 
*** 13.1.2 文本模式和二进制模式
**** 所有文件都是用二进制形式保存在存储间。
**** 文件最初是用字符来创造的，就是"文本文件"。
**** 文本文件包含"文本内容"。
**** 文件最初是用二进制值(机器代码)创造的(比如a.out、图片etc)，就是"二进制文件"。
**** 二进制文件包含"二进制内容"。
**** UNIX用同一种文件格式处理文本文件跟二进制文件。Ctrl+D表示文件结尾。
**** MS-DOS用Ctrl+Z表示文件结尾。(256个字符一行，用'\0'来填充空位，使每一行都是256)。
**** C有两种模式访问文件:二进制模式、文本模式。(为了规范文本易于处理)
***** 二进制模式访问MS-DOS文本文件会显示\r\n
***** 文件模式访问MS-DOS文本文件会显示\n(会转换)
***** C虽然提供两种模式，但是UNIX会用一种文件格式来开这两个模式。(囧，迷)
**** 
*** 13.1.3 I/O的级别
**** low-level I/O
***** 底层I/O:使用OS提供的基本I/O服务。
**** standard hight-level I/O 优先使用
***** 标准高级I/O:使用C库的标准包，因为无法保证所有OS的底层I/O一样
***** 可以移植到不同系统
**** 
*** 13.1.4 标准文件
**** C程序自动打开3个文件 P.415
***** (standard input)标准输入————默认键盘
****** stdin
***** (standard output)标准输出————默认显示器
****** stdout
****** 标准输出是putchar()、puts()、printf()使用的文件
***** (standard error ouput)标准错误输出————默认显示器
****** stderr
**** 
** 13.2 标准I/O
**** standard hight-level I/O 优点
***** 1)根据OS转换成terminal适应的字符
***** 2)input output都是"缓冲"
**** 缓冲区
***** 调用fopen会把数据分成512字节或倍数，作数据块一份份放进缓冲区。
**** 当程序读取文件，数据会copy到缓冲区
***** 缓冲区提升了传输速率
**** 
*** 13.2.1 检查命令行参数
**** int main(int argc, char * argv[])
****** 不懂就去12章复习
**** exit()
***** exit()关闭所有打开的文件并结束程序，参数传给操作系统，0是正常结束。其他知其他问题。
***** 0跟宏EXIT_SUCCESS用于表明成功结束程序，宏EXIT_FAILURE表明失败，宏跟exit()都在"stdlib.h"里面。
***** return 只能跳出函数，把控制权还给上一级递归，exit()直接结束程序
**** 
*** 13.2.2 fopen()函数
**** FILE * fopen(const char * path, const char * mode);
***** 第一个参数是要打开的文件的名字(文件名的字符串地址)
***** 第二个参数是模式("r""w""a""r+""w+""a+""rb"...P.417)(C11之后，"x",安全就是fopen失败了，也不会修改原文件)
****** 如果没有"x", 你用"w"打开，就算不懈东西，文件也会被清空
**** fopen()返回file pointer(文件指针)，用文件指针指向fopen的返回值
****** FILE * fp；
****** fp = fopen(note-13.org, "r");
***** fp并不指向实际文件，指向一个包含文件信息的"数据对象"(?)，其中包含包含操作文件的I/O函数使用的缓冲区信息(是否可以理解为实际在缓冲区鱼肉它?)
***** 标准库中I/O函数使用缓冲区，缓冲区被填充的程度、操作哪一个文件、还有位置，fp指向的就数据对象就是这些信息
***** 数据对象是C结构，14章见
**** 
*** 13.2.3 getc()和putc()
**** 妈的，不要跟gets()跟puts()搞混
****** ch = getc(fp);
****** putc(ch, stdout);
****** putc(ch, fp);	//把字符塞进fp指向的字符串代表的文件的位置里面
**** 
*** 13.2.4 文件结尾
**** 程序知道那里是文件结尾，get()到文件末尾会返回一个特殊值EOF。
**** 避免读到空文件，如果没有这一句，会ch=getc(末尾)，然后把EOF打出去
****** while ((ch = getc(fp)) != EOF)
****** {
******     putchar(ch);
****** }
**** 
*** 13.2.5 fclose()函数
**** fclose()函数关闭fp指定的文件，刷新缓冲区
**** 正常关闭返回值是0，失败返回EOF
****** if (fclose(fp) != 0)
******     fprintf(stderr, "Error in closing file %s\n", argv[1]);
**** 通常失败原因，硬盘满了、U盘被移除、I/0错误
**** 
*** 13.2.6 指向标准文件的指针
**** stdin
**** stdout
**** stderr
**** 
** 13.3 一个简单的文件压缩程序
**** 有意思的地方或技巧
**** 复制文件名
****** strncpy(name, argv[1], LEN - 5);	//拷贝文件名，无论argv[1]多长都要留下(LEN-5)的位置
****** name[LEN - 5] = '\0';			//？ 因为strcat()是从空字符开始粘贴所以要创造个'\0'，以防argv[1]过长
****** strcat(name, ".red");			//添加后缀
**** 同时打开了两个文件，同步操作
**** 
** 13.4 文件I/O:fprintf()、fscanf()、fgets()和fputs()
*** 13.4.1 fprintf()和fscanf()的函数
**** rewind(fp)；		//如果要多次使用这个文件内容，就必须这样回到文件开头，如果没有这个，会超出文件外
**** fscanf() 处理文件中的不同值(%d、%s...)有奇效。
****** fscanf(fp, "%s", words) == 1;
**** fprintf() 可以把文字重定向到文件
****** while((fscanf(stdin, "%40s", words) == 1) && (words[0] != '#'))	//从键盘输入字符串到words储存
******     fprintf(fp, "%s", words);					//把words的内容打印在fp指向的文件里面
**** 
*** 13.4.2 fgets()和fputs()函数
**** fgets(buf, STLEN, fp);
***** 保留'\n'
***** fgets读取输入到'\n'、文件末尾(EOF)或 STLEN-1，然后在末尾添加'\0'使变成string
***** 如果末尾是'\n'，会把'\n'放到'\0'之前
***** 遇到EOF会返回NULL，用于检查文件末尾
**** fputs(buf, fp);
***** 不添加'\n'
**** 
** 13.5 随机访问:fseek()和ftell()
**** 有趣的代码
****** #define CNTL_Z '\032'
****** ...
****** if ((fp = fopen(file, "rb")) == NULL)	//用二进制读取文件，所以能看到'\r\n'
****** ...
****** if (ch != CNTL_Z && ch != '\r')	//不处理MS-DOS的文本\r而到下个字符\n
******     putchar(ch);
**** 
*** 13.5.1 fseek()和ftell()的工作原理
**** 有趣的代码
****** long last;
****** char ch;
****** fseek(fp, 10L, SEEK_SET);	//把fp指向文件第10个字节位置
****** ch = getc(fp);			//把第10字节的字符赋值给ch
****** last = ftell(fp);		//把fp的所在的字节数字(10)赋值给last
**** SEEK_SET
***** 文件开始处
**** SEEK_CUR
***** 当前位置
**** SEEK_END
***** 文件末尾
**** 
*** 13.5.2 二进制模式和文本模式
**** 用文本模式打开MS-DOS的时候，C会把'\r\n'看成'\n'
**** 二进制模式打开MS-DOS的时候，程序可以看到'\r'
**** 
*** 13.5.3 可移植性
**** 不同OS可能在二进制模式中不支持SEEK_END模式，所以不一定能一直到不同系统
***** 可以用逐字节读取整个文件直到文件末尾。
**** 
*** 13.5.4 fgetpos()和fsetpos()函数
**** fseek() ftell用long(20亿bytes)可能处理不了更多字节的存储设备
**** fgetpos() fsetpos() —————— P426
***** 不使用long, 使用fpos_t类型
**** 
** 13.6 标准的I/O的机理
**** fopen()不知打开文件，还创建了缓冲区(读写模式会创造连两个缓冲区)以及一个包含文件很缓冲区数据的"结构"。
**** fopen()返回指向这个"结构"的指针。
**** "结构"通常包含一个指定流中当前位置的文件位置指示器(fp为什么会动)。
**** 还包含错误和文件结尾的指示器、一个指向缓冲区开始处的指针、一个文件标识符、一个计数(统计拷贝进缓冲区的字节数)
**** fopen()其实打开一个流(stream)。
***** stream：
****** 010100001010101010101001010100010101010101010010101001010101...
***** 就这样截取这段数据。
**** 使用标准I/O会把stdio.h的函数一起调入缓冲区。
**** 在使用fp读取数据时，"文件位置指示器"就被设置为"指向刚读取字符的下一个字符"(为什么每次循环，不用设置fp递增他都会自己动)
**** 当输入函数发现已读完缓冲区中所有字符，会请求把下一个缓冲大小的"数据块"从文件copy到该缓冲区中，直到读完所有数据块——————直到文件结尾。
**** 到文件结尾，结尾指示器设置为真， 被调用到下个函数返回EOF。
**** 到数据填满缓冲区，数据就会copy到文件中。
**** 
** 13.7 其他标准的I/O函数
**** P.428
**** ugetc()
**** fflush()
**** setvbuf()
**** fread() fwrite()
**** fwrite()
**** fread()
**** feof() ferror()
*** 13.7.8示例
**** P.431 append.c 展现各种函数
*** 13.7.9 用二进制I/O进行随机访问
**** 读取文本数据，抽取字节段来显示数据
****** while (scanf("%d", &i) == 1 && i >= 0 && i < ARSIZE)
****** {
******     pos = (long) i * sizeof(double);
******     fseek(iofile, pos, SEEK_SET);
******     fread(&value, sizeof(double), 1, iofile);
******     printf("The value there is %f.\n", value);
******     printf("Next index (out of range to quit):\n");
****** }
